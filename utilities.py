import numpy as np

from Chandra import Time

from bad_times import nsm, ssm

def overlap(table1, table2):
    """This function looks for overlap between two sets of ranges, 
    usually times, formatted in seconds. 
    
    It will output a boolean array equal in length to table1.
    Each input table must be formatted with two columns: 
    range start and range stop.
    The output will be True if the corresponding range in table1
    overlaps with any range in table2.  The output will be
    otherwise False.
    """
    out = np.zeros(np.size(table1, axis=0), dtype='bool')
    for i in range(np.size(table1, axis=0)):
        s1_s2 = table1[i, 0] < table2[:, 0] 
        s1_e2 = table1[i, 0] <= table2[:, 1]
        e1_s2 = table1[i, 1] < table2[:, 0]
        e1_e2 = table1[i, 1] < table2[:, 1]
        # no overlap occurs when all four parameters above either == 0 or 1
        sum_params = np.sum(np.array([s1_s2, s1_e2, e1_s2, e1_e2]), axis=0)
        olap = (sum_params == 1) | (sum_params == 2) | (sum_params == 3)
        out[i] = np.any(olap)
    return out

def str_to_secs(table):
    """This function will take a table of time ranges formatted as strings 
    (compatible with bad_times) and convert it to an nx2 array in DateTime 
    seconds
    """
    out = np.zeros([len(table), 2])
    for i in range(len(table)):
        t1, t2 = table[i].split()
        out[i, 0] = Time.DateTime(t1).secs
        out[i, 1] = Time.DateTime(t2).secs
    return out    

def read_torque_table(table):
    """This function reads a comma-delimited text file of 31x136 solar torque  
    values and outputs the values as an array
    """
    f = open(table)
    lines = f.readlines()
    f.close()
    out = np.zeros((61, 136))
    line_num = 0
    for line in lines:
        fields = line.split()
        out[line_num, :] = [float(field) for field in fields]
        line_num = line_num + 1
    return out

def write_torque_table(A, filename):
    """This function writes an array A to a comma-delimited text file with a 
    user-defined filename.
    """
    f = open(filename, 'w')
    for row in range(np.size(A, axis=0)):
        A[row,:].tofile(f, sep=',')
        f.write('\n')
    f.close()    

def read_MCC_results(table):
    """This function reads a fixed-width text file generated by MCC's momentum
    plot using the telemetry overlay and Plot2Text functions.
    Returns time, predictions, actual values
    """
    f = open(table)
    lines = f.readlines()
    lines = lines[1:] # discard header line
    f.close()
    t = np.zeros(len(lines))
    predicts = np.zeros((len(lines), 3))
    actuals = np.zeros((len(lines), 3))
    line_num = 0
    for line in lines:
        fields = line.split()
        t[line_num] = Time.DateTime(fields[0]).secs
        predicts[line_num, :] = [float(field) for field in fields[1:4]]
        actuals[line_num, :] = [float(field) for field in fields[5:8]]
        line_num = line_num + 1
    return t, predicts, actuals

def find_closest(a, b):
    """This function returns an array of length a with the indices of 
    array b that are closest to the values of array a.
    """
    a = np.atleast_1d(np.array(a))
    b = np.atleast_1d(np.array(b))
    out = [np.argmin(abs(b - a1)) for a1 in a]
    return out
    
def find_last_before(a, b):
    """This function returns an array of length a with the indices of 
    array b that are closest without going over the values of array a.
    (Bob Barker rules.  Assumes b is sorted by magnitude.)
    """
    a = np.atleast_1d(np.array(a))
    b = np.atleast_1d(np.array(b))
    out = np.zeros(len(a), dtype='int32')
    for i in range(len(a)):
        out_i = np.argmin(abs(b - a[i]))
        if b[out_i] > a[i]:
            out_i = out_i - 1
        out[i] = out_i
    return out    
     
def find_first_after(a, b):
    """This function returns an array of length a with the indices of 
    array b that are closest without being less than the values of array a.
    (Opposite of Bob Barker rules.  Assumes b is sorted by magnitude.)
    """
    a = np.atleast_1d(np.array(a))
    b = np.atleast_1d(np.array(b))
    out = np.zeros(len(a), dtype='int32')
    for i in range(len(a)):
        out_i = np.argmin(abs(b - a[i]))
        if b[out_i] < a[i]:
            out_i = out_i + 1
        out[i] = out_i
    return out  
    
def append_rss(A):
    """This function appends the squareroot of the sum of the squares
    of all the other values in each row.  
    """
    rss = np.sqrt(np.diag(A.dot(A.transpose()))) 
    out = np.hstack((A, np.atleast_2d(rss).transpose())) 
    return out

def ceil_to_value(number, round_to):
    """This function rounds a given input up to the nearest even multiple
    of the supplied "roundto" input
    """
    number = float(number)
    round_to = float(round_to)
    return (np.ceil(number / round_to) * round_to)    